<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algoritmos</title>
    <link rel="stylesheet" href="Algoritmos.css">
    <link href="https://fonts.googleapis.com/css2?family=Fredoka&display=swap" rel="stylesheet">
</head>
<body>
    <header class="navbar">
        <nav>
            <div class="desktop-nav">
                <a href="../../index.php" class="nav-item">Inicio</a>
                <a href="../../login.php" class="nav-item">Proceso de votación</a>
                <a href="../../faq.html" class="nav-item">Preguntas Frecuentes</a>
                <a href="#" class="nav-item active">Algoritmos</a>
            </div>
            <div class="mobile-nav-toggle">
                <span class="icon-up">&#8964;</span>
                <span class="icon-down" style="display: none;">&#8963;</span>
            </div>
            <div class="mobile-nav-menu">
                <a href="#" class="nav-item">Inicio</a>
                <a href="#" class="nav-item">Proceso de votación</a>
                <a href="#" class="nav-item">Preguntas frecuentes</a>
                <a href="#" class="nav-item active">Algoritmos</a>
            </div>
        </nav>
    </header>

    <main class="container">
        <h1>Sección Informativa sobre Algoritmos</h1>
        <p>Aquí puedes ver distintos algoritmos, desde sus conceptos, hasta el código e incluso ejecutarlos.</p>

        <div class="algorithm-section">
            <div class="tabs">
                <button class="tab-button active" data-tab="avestruz">Algoritmo del Avestruz</button>
                <button class="tab-button" data-tab="banquero-un-recurso">Algoritmo del Banquero (un Recurso)</button>
                <button class="tab-button" data-tab="banquero-varios-recursos">Algoritmo del Banquero (varios Recursos)</button>
                <button class="tab-button" data-tab="filosofos">Problema de los Filósofos</button>
                <button class="tab-button" data-tab="lectores-escritores">Problema de Lectores Escritores</button>
                <button class="tab-button" data-tab="barbero-durmiente">Problema del Barbero Durmiente</button>
            </div>

            <div class="tab-content">
                <div class="info-panel active" id="avestruz-content">
                    <div class="info-text">
                        <h3>Algoritmo del Avestruz</h3>
                        <p>El Algoritmo del Avestruz no es realmente un algoritmo en el sentido tradicional, sino más bien una estrategia o enfoque de diseño de sistemas. Su nombre es una alusión irónica al comportamiento de las avestruces de enterrar la cabeza en la arena para ignorar un problema con la esperanza de que nunca ocurra. Propuesto por <strong>Andrew Tanenbaum</strong> como una metáfora para ciertas estrategias en la gestión de errores y concurrencia.</p>
                        <p><strong>¿Qué es?</strong> Consiste en ignorar intencionalmente condiciones de carrera o errores poco frecuentes en sistemas concurrentes o distribuidos. Se basa en la suposición de que:</p>
                        <ul>
                            <li>Son raros.</li>
                            <li>El costo de manejarlos supera el beneficio.</li>
                            <li>El sistema puede tolerar sus efectos ocasionales.</li>
                        </ul>
                        <p><strong>¿Cómo funciona?</strong> En lugar de implementar mecanismos complejos de sincronización o detección de errores para cada posible problema, se asume que ciertos fallos son tan infrecuentes o sus consecuencias tan menores que es más eficiente simplemente ignorarlos. Se aplica en situaciones donde la detección y corrección de un error es más costosa o compleja que el propio error.</p>
                        <p><strong>Características:</strong> Simplicidad, bajo overhead. <strong>Restricciones:</strong> No es adecuado para sistemas donde la confiabilidad es crítica o donde los errores pueden tener consecuencias graves.</p>
                    </div>
                    <div class="code-console-wrapper">
                        <div class="code-area">
                            <pre><code class="language-javascript">
// Algoritmo del Avestruz (simulación)
function runOstrichAlgorithm() {
    let data = 0;
    try {
        if (Math.random() < 0.1) { 
            throw new Error("Error poco frecuente ocurrido.");
        }
        data = 100 / (Math.random() > 0.5 ? 1 : 0);
        return `Operación completada, resultado: ${data}`;
    } catch (e) {
        return "Un error ocurrió, pero fue ignorado (Algoritmo del Avestruz).";
    }
}
                            </code></pre>
                        </div>
                        <div class="console">
                            <div class="output" id="avestruz-output"></div>
                            <div class="input-area">
                                <span class="prompt">> </span><input type="text" class="console-input" data-target="avestruz-output" data-algorithm="avestruz">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="info-panel" id="banquero-un-recurso-content">
                    <div class="info-text">
                        <h3>Algoritmo del Banquero para un solo Recurso</h3>
                        <p>El Algoritmo del Banquero es un algoritmo de prevención de interbloqueos (deadlock) y fue propuesto por <strong>Edsger W. Dijkstra</strong>. Se utiliza en sistemas operativos para asignar recursos de forma segura a múltiples procesos, evitando situaciones de interbloqueo.</p>
                        <p><strong>¿Qué es?</strong> Es un algoritmo que evalúa las solicitudes de recursos de los procesos para garantizar que el sistema siempre permanezca en un "estado seguro", es decir, un estado desde el cual se puede evitar el interbloqueo.</p>
                        <p><strong>¿Cómo funciona?</strong> Para un solo tipo de recurso, el algoritmo mantiene un registro de la cantidad total de ese recurso disponible, la cantidad asignada a cada proceso y la cantidad máxima que cada proceso puede solicitar. Cuando un proceso solicita recursos, el algoritmo verifica si la concesión de esa solicitud llevaría al sistema a un estado inseguro. Si es así, la solicitud se retrasa hasta que sea seguro concederla. Si es seguro, se concede.</p>
                        <p><strong>Características:</strong> Previene interbloqueos. <strong>Restricciones:</strong> Requiere que los procesos declaren su necesidad máxima de recursos por adelantado. Puede ser ineficiente si los procesos solicitan y liberan recursos constantemente.</p>
                    </div>
                    <div class="code-console-wrapper">
                        <div class="code-area">
                            <pre><code class="language-javascript">
// Algoritmo del Banquero (un recurso - simulación)
function runBankerSingleResource() {
    let totalResources = 10;
    let availableResources = 10;
    let maxNeeds = { P1: 5, P2: 4, P3: 6 };
    let allocated = { P1: 0, P2: 0, P3: 0 };
    let output = [];

    function requestResources(process, amount) {
        output.push(`\n${process} solicita ${amount} recurso(s).`);
        if (amount > maxNeeds[process] - allocated[process]) {
            output.push(`  Error: ${process} excede su necesidad máxima.`);
            return false;
        }
        if (amount > availableResources) {
            output.push(`  ${process} debe esperar: recursos insuficientes disponibles.`);
            return false;
        }

        availableResources -= amount;
        allocated[process] += amount;

        output.push(`  Estado actual: Disponible=${availableResources}, Asignado: P1=${allocated.P1}, P2=${allocated.P2}, P3=${allocated.P3}`);

        let isSafe = availableResources >= 0; 
        output.push(`  ¿Es un estado seguro? ${isSafe ? 'Sí' : 'No'}`);
        return isSafe;
    }

    output.push("Inicio de la simulación del Banquero (un recurso):");
    requestResources('P1', 2);
    requestResources('P2', 3);
    requestResources('P3', 1);
    requestResources('P1', 3);
    requestResources('P2', 1);
    requestResources('P3', 5);

    return output.join('\n');
}
                            </code></pre>
                        </div>
                        <div class="console">
                            <div class="output" id="banquero-un-recurso-output"></div>
                            <div class="input-area">
                                <span class="prompt">> </span><input type="text" class="console-input" data-target="banquero-un-recurso-output" data-algorithm="banquero-un-recurso">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="info-panel" id="banquero-varios-recursos-content">
                    <div class="info-text">
                        <h3>Algoritmo del Banquero para Varios Recursos</h3>
                        <p>Esta es una extensión del Algoritmo del Banquero original de <strong>Edsger W. Dijkstra</strong>, aplicado a escenarios donde hay múltiples tipos de recursos, cada uno con una cantidad diferente.</p>
                        <p><strong>¿Qué es?</strong> Es una generalización del algoritmo del banquero que permite la asignación segura de múltiples tipos de recursos a varios procesos, garantizando que el sistema nunca llegue a un estado de interbloqueo.</p>
                        <p><strong>¿Cómo funciona?</strong> El algoritmo mantiene varias matrices para llevar el control: <code>Available</code> (recursos disponibles de cada tipo), <code>Max</code> (necesidad máxima de cada proceso para cada tipo de recurso), <code>Allocation</code> (recursos asignados actualmente a cada proceso de cada tipo) y <code>Need</code> (recursos adicionales que cada proceso aún necesita de cada tipo). Cuando un proceso solicita recursos, el algoritmo realiza una verificación de seguridad que intenta encontrar una secuencia de ejecución de procesos que permita a todos terminar, liberando sus recursos. Si se encuentra tal secuencia, la solicitud se concede; de lo contrario, se retrasa.</p>
                        <p><strong>Características:</strong> Previene interbloqueos en sistemas con múltiples recursos. <strong>Restricciones:</strong> Es más complejo de implementar y computacionalmente más costoso que la versión de un solo recurso. También requiere la declaración previa de la necesidad máxima de recursos.</p>
                    </div>
                    <div class="code-console-wrapper">
                        <div class="code-area">
                            <pre><code class="language-javascript">
// Algoritmo del Banquero (varios recursos - simulación)
function runBankerMultiResource() {
    let available = [3, 3, 2];
    let max = [
        [7, 5, 3],
        [3, 2, 2],
        [9, 0, 2]
    ];
    let allocation = [
        [0, 1, 0],
        [2, 0, 0],
        [3, 0, 2]
    ];
    let need = [
        [7, 4, 3],
        [1, 2, 2],
        [6, 0, 0]
    ];
    let output = [];

    output.push("Estado inicial:");
    output.push(`  Available: [${available.join(', ')}]`);
    output.push(`  Need: ${JSON.stringify(need)}`);
    output.push(`  Allocation: ${JSON.stringify(allocation)}`);

    let isSystemSafe = true;

    for (let i = 0; i < need.length; i++) {
        for (let j = 0; j < available.length; j++) {
            if (need[i][j] > (available[j] + allocation[i][j])) {
                isSystemSafe = false;
                break;
            }
        }
        if (!isSystemSafe) break;
    }

    output.push(`\n¿Es el sistema un estado seguro (verificación básica)? ${isSystemSafe ? 'Sí' : 'No'}`);
    output.push("  Nota: La verificación de seguridad completa es más compleja y busca una secuencia de ejecución.");
    return output.join('\n');
}
                            </code></pre>
                        </div>
                        <div class="console">
                            <div class="output" id="banquero-varios-recursos-output"></div>
                            <div class="input-area">
                                <span class="prompt">> </span><input type="text" class="console-input" data-target="banquero-varios-recursos-output" data-algorithm="banquero-varios-recursos">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="info-panel" id="filosofos-content">
                    <div class="info-text">
                        <h3>Problema de los Filósofos Comelones</h3>
                        <p>Este es un problema clásico de concurrencia propuesto por <strong>Edsger W. Dijkstra</strong> para ilustrar problemas de sincronización en sistemas operativos, como el interbloqueo y la inanición (starvation).</p>
                        <p><strong>¿Qué es?</strong> Describe un escenario donde cinco filósofos se sientan alrededor de una mesa, alternando entre pensar y comer. Hay cinco palillos, uno entre cada par de filósofos. Para comer, un filósofo necesita dos palillos: el de su izquierda y el de su derecha. El problema reside en diseñar un protocolo para que los filósofos puedan comer sin que ocurra un interbloqueo o inanición.</p>
                        <p><strong>¿Cómo funciona?</strong> Si cada filósofo toma primero el palillo de su izquierda y luego intenta tomar el de su derecha, y todos lo hacen simultáneamente, todos tomarán un palillo y esperarán indefinidamente el segundo, resultando en un interbloqueo. Las soluciones suelen involucrar el uso de semáforos, monitores o restricciones en el orden de adquisición de recursos para evitar el interbloqueo y la inanición.</p>
                        <p><strong>Características:</strong> Es un excelente ejemplo para estudiar interbloqueos y estrategias de sincronización. <strong>Restricciones:</strong> No es un algoritmo para ser implementado directamente, sino un modelo para comprender y resolver problemas de concurrencia.</p>
                    </div>
                    <div class="code-console-wrapper">
                        <div class="code-area">
                            <pre><code class="language-javascript">
// Problema de los Filósofos Comelones (simulación conceptual)
function runPhilosophersProblem() {
    let output = [];
    const numPhilosophers = 5;
    const chopsticks = Array(numPhilosophers).fill(true);
    const philosopherStates = Array(numPhilosophers).fill('thinking');

    function tryEat(philosopherId) {
        const leftChopstick = philosopherId;
        const rightChopstick = (philosopherId + 1) % numPhilosophers;

        output.push(`Filósofo ${philosopherId} está ${philosopherStates[philosopherId]}.`);

        if (philosopherStates[philosopherId] === 'hungry') {
            if (chopsticks[leftChopstick] && chopsticks[rightChopstick]) {
                chopsticks[leftChopstick] = false;
                chopsticks[rightChopstick] = false;
                philosopherStates[philosopherId] = 'eating';
                output.push(`  Filósofo ${philosopherId} tomó los palillos y está comiendo.`);
                return true;
            } else {
                output.push(`  Filósofo ${philosopherId} no pudo tomar ambos palillos, sigue hambriento.`);
                return false;
            }
        }
        return false;
    }

    output.push("Inicio de la simulación de los Filósofos Comelones:");

    for (let i = 0; i < numPhilosophers; i++) {
        philosopherStates[i] = 'hungry';
    }

    let ateCount = 0;
    let attempts = 0;
    while (ateCount < numPhilosophers && attempts < 10) { 
        output.push(`\n--- Intento de ciclo ${attempts + 1} ---`);
        ateCount = 0;
        for (let i = 0; i < numPhilosophers; i++) {
            if (philosopherStates[i] === 'hungry') {
                if (tryEat(i)) {
                    ateCount++;
                }
            } else if (philosopherStates[i] === 'eating') {
                output.push(`  Filósofo ${i} sigue comiendo.`);
                ateCount++;
            } else {
                output.push(`  Filósofo ${i} está pensando.`);
            }
        }
        attempts++;
    }

    if (ateCount < numPhilosophers) {
        output.push("\nCondición de interbloqueo simulada: Algunos filósofos siguen hambrientos.");
    } else {
        output.push("\nSimulación completada: Todos los filósofos comieron.");
    }
    return output.join('\n');
}
                            </code></pre>
                        </div>
                        <div class="console">
                            <div class="output" id="filosofos-output"></div>
                            <div class="input-area">
                                <span class="prompt">> </span><input type="text" class="console-input" data-target="filosofos-output" data-algorithm="filosofos">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="info-panel" id="lectores-escritores-content">
                    <div class="info-text">
                        <h3>Problema de Lectores y Escritores</h3>
                        <p>Este es otro problema clásico de sincronización en sistemas operativos, diseñado para explorar la concurrencia en el acceso a recursos compartidos. Fue formulado por <strong>P.J. Courtois, F. Heymans, y D.L. Parnas</strong>.</p>
                        <p><strong>¿Qué es?</strong> Un problema donde varios procesos ("lectores") necesitan leer datos de una base de datos compartida y otros procesos ("escritores") necesitan escribir en ella. La regla es que múltiples lectores pueden acceder a la vez, pero solo un escritor puede acceder a la vez, y ningún lector puede acceder mientras un escritor está escribiendo.</p>
                        <p><strong>¿Cómo funciona?</strong> Se utilizan semáforos o monitores para controlar el acceso a la base de datos. Existen varias soluciones, cada una con diferentes prioridades. La primera solución da prioridad a los lectores (nuevos lectores pueden entrar incluso si un escritor está esperando), mientras que la segunda da prioridad a los escritores (si un escritor está esperando, ningún nuevo lector puede entrar). Las soluciones más robustas buscan evitar tanto la inanición de lectores como de escritores.</p>
                        <p><strong>Características:</strong> Ilustra cómo gestionar el acceso concurrente a datos compartidos. <strong>Restricciones:</strong> La implementación correcta es crucial para evitar interbloqueos, inanición o corrupción de datos. Priorizar un tipo de proceso puede llevar a la inanición del otro.</p>
                    </div>
                    <div class="code-console-wrapper">
                        <div class="code-area">
                            <pre><code class="language-javascript">
// Problema de Lectores y Escritores (Prioridad a Lectores - simulación)
function runReadersWritersProblem() {
    let output = [];
    let database = "Datos iniciales";
    let readersReading = 0;
    let writerActive = false;
    let writerWaiting = false;

    function acquireReadLock(readerId) {
        if (writerActive || writerWaiting) {
            output.push(`Lector ${readerId}: Esperando (escritor activo o esperando).`);
            return false;
        }
        readersReading++;
        output.push(`Lector ${readerId}: Acceso de lectura concedido. Lectores activos: ${readersReading}`);
        return true;
    }

    function releaseReadLock(readerId) {
        readersReading--;
        output.push(`Lector ${readerId}: Lectura completada. Lectores activos: ${readersReading}`);
    }

    function acquireWriteLock(writerId) {
        if (readersReading > 0 || writerActive) {
            writerWaiting = true;
            output.push(`Escritor ${writerId}: Esperando (lectores activos o otro escritor).`);
            return false;
        }
        writerActive = true;
        writerWaiting = false;
        output.push(`Escritor ${writerId}: Acceso de escritura concedido.`);
        return true;
    }

    function releaseWriteLock(writerId) {
        writerActive = false;
        output.push(`Escritor ${writerId}: Escritura completada.`);
    }

    output.push("Inicio de la simulación de Lectores-Escritores (Prioridad a Lectores):");

    output.push("\n-- Escenario 1: Múltiples lectores acceden --");
    if (acquireReadLock(1)) { database; releaseReadLock(1); }
    if (acquireReadLock(2)) { database; releaseReadLock(2); }
    if (acquireReadLock(3)) { database; releaseReadLock(3); }

    output.push("\n-- Escenario 2: Escritor intenta acceder mientras hay lectores --");
    acquireReadLock(4);
    if (acquireWriteLock(1)) { database = "Nuevos datos"; releaseWriteLock(1); }
    releaseReadLock(4);

    output.push("\n-- Escenario 3: Escritor accede cuando no hay lectores --");
    if (acquireWriteLock(2)) { database = "Más datos"; releaseWriteLock(2); }

    output.push(`\nEstado final de la base de datos: "${database}"`);
    return output.join('\n');
}
                            </code></pre>
                        </div>
                        <div class="console">
                            <div class="output" id="lectores-escritores-output"></div>
                            <div class="input-area">
                                <span class="prompt">> </span><input type="text" class="console-input" data-target="lectores-escritores-output" data-algorithm="lectores-escritores">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="info-panel" id="barbero-durmiente-content">
                    <div class="info-text">
                        <h3>Problema del Barbero Durmiente</h3>
                        <p>El Problema del Barbero Durmiente es un problema clásico de sincronización de procesos en sistemas operativos, que fue propuesto por <strong>Edsger W. Dijkstra</strong> y sirve para ilustrar los problemas de coordinación entre procesos.</p>
                        <p><strong>¿Qué es?</strong> Describe una barbería con un barbero, una silla de barbero y varias sillas para clientes esperando. Si no hay clientes, el barbero se duerme. Cuando un cliente llega y el barbero está dormido, lo despierta. Si el barbero está ocupado, el cliente se sienta en una silla de espera (si hay espacio) o se va si no hay sillas disponibles.</p>
                        <p><strong>¿Cómo funciona?</strong> Se utilizan semáforos para coordinar al barbero y a los clientes. Un semáforo para el barbero (dormido/despierto), uno para los clientes esperando, y otro para proteger el acceso a las sillas de espera. Los clientes incrementan un contador de espera y el barbero lo decrementa. Si el contador llega a cero, el barbero se duerme.</p>
                        <p><strong>Características:</strong> Es un buen ejemplo para ilustrar la sincronización productor-consumidor. <strong>Restricciones:</strong> La implementación debe manejar correctamente las condiciones de carrera para el número de sillas de espera y la lógica de despertado/dormido del barbero.</p>
                    </div>
                    <div class="code-console-wrapper">
                        <div class="code-area">
                            <pre><code class="language-javascript">
// Problema del Barbero Durmiente (simulación conceptual asíncrona)
function runSleepingBarberProblem() {
    let output = [];
    const MAX_CHAIRS = 3;
    let waitingCustomers = 0;
    let barberSleeping = true;
    let barberChairOccupied = false;

    function simulateHaircut(customerId) {
        return new Promise(resolve => {
            barberChairOccupied = true;
            output.push(`Barbero: Cortando el pelo al Cliente ${customerId}.`);
            setTimeout(() => {
                output.push(`Barbero: Terminé con Cliente ${customerId}.`);
                barberChairOccupied = false;
                resolve();
            }, 50); 
        });
    }

    async function barberLoop() {
        for(let i = 0; i < 20; i++) { 
            if (waitingCustomers > 0 && !barberChairOccupied) {
                barberSleeping = false;
                output.push(`Barbero: Un cliente espera. Clientes esperando: ${waitingCustomers}`);
                const currentCustomer = "Cliente_" + (Math.random() * 100).toFixed(0); 
                waitingCustomers--;
                await simulateHaircut(currentCustomer);
            } else if (waitingCustomers === 0 && !barberSleeping) {
                barberSleeping = true;
                output.push(`Barbero: No hay clientes, me voy a dormir.`);
            }
            await new Promise(resolve => setTimeout(resolve, 10)); 
        }
    }

    output.push("Inicio de la simulación del Barbero Durmiente:");
    
    if (waitingCustomers === 0 && barberSleeping) {
        output.push("Barbero: Esperando clientes (dormido).");
    }

    function customerArrives(id, delay) {
        setTimeout(() => {
            output.push(`\nCliente ${id} llega.`);
            if (waitingCustomers < MAX_CHAIRS) {
                waitingCustomers++;
                output.push(`  Cliente ${id} se sienta en la sala de espera. Clientes esperando: ${waitingCustomers}`);
                if (barberSleeping && !barberChairOccupied) {
                    barberSleeping = false;
                    output.push(`  Cliente ${id} despierta al barbero.`);
                    barberLoop();
                }
            } else {
                output.push(`  Sala de espera llena. Cliente ${id} se va.`);
            }
        }, delay);
    }

    customerArrives(1, 50);
    customerArrives(2, 150);
    customerArrives(3, 250);
    customerArrives(4, 350); 
    customerArrives(5, 450);

    barberLoop(); 

    return "Simulación asíncrona iniciada. La salida aparecerá con el tiempo.";
}
                            </code></pre>
                        </div>
                        <div class="console">
                            <div class="output" id="barbero-durmiente-output"></div>
                            <div class="input-area">
                                <span class="prompt">> </span><input type="text" class="console-input" data-target="barbero-durmiente-output" data-algorithm="barbero-durmiente">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer class="footer">
        <p>Heyden Aldana - Héctor Funes - Bilander Fernández</p>
        <p>Copyright &copy; todos los derechos reservados.</p>
        <p>Este es un proyecto simulado y no corresponde al modelo actual del sistema de elecciones generales en Honduras.</p>
    </footer>

    <script src="script.js"></script>
</body>
</html>